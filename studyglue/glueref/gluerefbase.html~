<ol><li>20130724 air glue.sas annotated code&#160;test data output superdata<ol><li>meta:<ol><li>glue.sas code below was copied on 20130724 from&#160;<ol><li>C:/CVSProjects/CSSCScoreReporting/OGT Fall 2012/code/development/superdata/glue.sas</li><li>NB: some empty lines were squashed, so line numbers may be akimbo.</li><li>I manually insert list item with /**/ in here at times to simulate blank lines to &#160;adjust item/line numbering in this entry.</li></ol></li><li>-glue.sas march 2013 output data<ol><li>location&#160;H:\share\Ohio Graduation Tests\Technical\2013 March\ScoreReports\SuperData</li></ol></li><li>test data:&#160;<ol><li>C:\Users\temp_rphillips\testdata\OGT_2012_Spring</li><li>inputs:<ol><li>ogt_csv</li></ol></li><li>outputs:<ol><li>student.csv, student-dummy.csv, ogt_galludet.csv</li></ol></li></ol></li><li>test code : python code on air desktop&#160;<ol><li>mostly in python notebooks like 20130812_glue...*</li></ol></li></ol></li><li>ISSUE: Should create a python version of &#160;Propercase&#160;<ol><ol><li>- it exists in ScoreReportMacros/UnitTested/lib_properCase.sas, and a ref exists in python code that it is genned by prep_sqlserver, but no sign of that in Mercurial using Eclipse ctrl-h on rev 375.</li><li>- CONCLUSION - Yes..</li><li>UPDATE - we do have a propcase.py - but I had missed it looking for proper, not prop.</li></ol></ol></li><li>Issue: line 165 - is this a one-off special setting for a particular year or ongoing 'service' to recode?</li><li>Issue: line 189 - what is the real-world condition detected here?</li><li>Issue: lines 174-231 - what is otherdnp, specifically dnp (NFL says it is "did not play") ?<ol><li>Found similar: var *dnp: they are vars in agg sheet: Means,&#160;<ol><li>&#160;see rows 17-51 for bp{S}xNNdnp vars...</li></ol></li><li>-</li></ol></li><li>Issue: should probably use a different schema per admin, eg OGT2013Fall, OAT2012Summer, etc, or suffix of YYYYMM to indicate a month.<ol><li>brought this up at 20130730 python checkin meeting&#160;</li><li>RESOLVED: and paul said not needed... just use our main db,&#160;<ol><li>as study data of the db will be picked up and archived as needed by pre and post "glue" type processing.</li></ol></li></ol></li><li>Issue: Maybe record a table "parameters" or "context" to record the revision of code used for the study.</li><li>Issue: maybe have a 'run_id" for each run of the glue code, so do not overwrite old output sets when rerun code..?- RESOLVED : No need.</li><li>Issue line 276: what is this check for?</li><li>-</li></ol></li><li>annotated glue.sas code content: (1) next-level items numbers are glue.sas orig line numbers, and comments are sub-items of &#160;line number level.<ol><li>/*proc printto log="H:\share\Ohio Graduation Tests\Technical\2012 March\ScoreReports\Superdata\superdata0508log.txt" new;*/</li><li>/*run;*/</li><li>Options nomprint nosymbolgen;</li><li>%let cvsroot=\\tsclient\C\Projects;<ol><li>SETUP some variables, libraries for base paths,&#160;</li></ol></li><li>%let cvspath=&amp;cvsroot.\CSSC Score Reporting\OGT Spring 2012\Code\Development;</li><li>/**/</li><li>libname input "H:\share\Ohio Graduation Tests\Technical\2012 October\ScoreReports\PostComplimentaryMergeData";<ol><li>libname input<ol><li>used by: line 572 call:&#160;%OGT(inputds=input.ogt);&#160;<ol><li>-</li></ol></li></ol></li><li>it is the container for the main input dataset 'ogt'.</li></ol></li><li>libname intake "H:\share\Ohio Graduation Tests\Technical\2012 October\ScoreReports\PostIntakeData";<ol><li>ISSUE: found no use of this libname in glue.sas...&#160;<ol><li>can it be used by called macros?-check that later</li></ol></li></ol></li><li>/*Normal output Data*/</li><li>Libname output "H:\share\Ohio Graduation Tests\Technical\2012 October\ScoreReports\Superdata";<ol><li>libname output</li><li>used &#160;in 23 places in glue.sas - main output directory/container</li></ol></li><li>/*Libname Output "C:\testning\ogts10\output";*/</li><li>/**/</li><li>libname similar "&amp;cvsroot.\CSSC Score Reporting\Ohio Spring 2007\Documents";<ol><li>pcdata=similar.similardist is only &#160;used in line 412 as param to PeerCompare()</li><li>end libraries setup</li><li>START includes of code</li></ol></li><li>/**/</li><li>%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\safeexcelread.sas";</li><li>%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\BookMapReader.sas";</li><li>%include "&amp;cvsroot.\CSSC Score Reporting\OGT Fall 2010\Code\Development\Convert_To_Dotmissing.sas";</li><li>/*%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\peercompare.sas";*/</li><li>%include "&amp;cvsroot.\CSSC Score Reporting\OGT Fall 2010\Code\Development\peercompare.sas";</li><li>%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\ttest.sas";</li><li>%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\cascade.sas";</li><li>%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\means.sas";</li><li>/**/</li><li>%include "&amp;cvsroot.\CSSC Score Reporting\OGT Fall 2010\Code\Development\suppression.sas";</li><li>/**/</li><li>%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\lib_propercase.sas";</li><li>%include "&amp;cvsroot.\ScoreReportMacros\UnitTested\lib_wordcnt.sas";</li><li>/*%include "&amp;cvsroot.\CSSC Score Reporting\OGT Summer 2007\Code\Development\ScaleScoreFreq.sas";*/</li><li>/* rvp added this line locally to normalize line numbers in annotations */</li><li>/**********need change -- start;*********************/<ol><li>Did some sas code includes.</li></ol></li><li>%let bkmap_loc_file=&amp;CVSRoot.\CSSC Score Reporting\OGT Fall 2012\Code\Development\Intake\BookMapLocations1.xls;<ol><li>Did set the cvs bkmap_loc_file for ogt fall 2012</li></ol></li><li>%let DataLayout = &amp;CVSRoot.\CSSC Score Reporting\OGT Fall 2012\Intake Layout\OGT_FA12_Op_DataLayout_IntakeLayout.xls;<ol><li>DataLayout - the cvs intakelayout xls file</li></ol></li><li>/**********need change -- end;*********************/</li><li>%let agg_file=&amp;cvsroot.\CSSC Score Reporting\OGT Fall 2012\Code\Development\Superdata\AggregationSheet.xls;<ol><li>agg_file - main workbook with multiple spreadsheets with most glue.sas input parameters</li></ol></li><li>/*need change*/</li><li>/*%let cnty_name_file=&amp;cvsroot.\CSSC Score Reporting\OGT Spring 2012\Code\Development\CountyNames.xls;*/<ol><li>Above COMMENTED out: var for cnty_name_file -- comment below says that intake code now 'does this'.&#160;</li></ol></li><li>%let subject_list= R M W S C;<ol><li>Did set first of &#160;a few CONSTANT PARAMS in glue.sas set once here:</li><li>-Constant parameters: Subject_list, grade, form_list, form=base</li></ol></li><li>%let admin=Spring;<ol><li>-</li></ol></li><li>%let grade=10;</li><li>%let dummy_grade=10;</li><li>%let form_list=A B;</li><li>%let form=base;<ol><li>That set up parameters subject, admin, grade, form_list, form, . . .</li></ol></li><li>/**/</li><li>%Bookmapreader(excel=Y,</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; inputds=,</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; inputfile=&amp;bkmap_loc_file.,</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; inputsheet=Bookmap);<ol><li>Called &#160;Bookmapreader( . . . ) which did . . .&#160;</li><li>Bookmapreader() set a plethora of macro vars to represent the entire set of bookmaps, N of rows in diff cats, even arrays of &#160;values where items were or were not 'released'.<ol><li>Some BookmapReader()-created &#160;vars used below &#160;by glue.sas:&#160;<ol><li>Item_NotReleased*_A_*,&#160;<ol><li>derived by...see BookmapReader line 184.</li></ol></li><li>&#160;MaxItem*_A_,&#160;<ol><li>see BookmapReader line 191</li></ol></li><li>&#160;MC_Released_*_A_*<ol><li>see line 156 of BookmapReader()</li></ol></li></ol></li><li>SO - investigate form type 'A" and what it means... in a business sense.<ol><li>OK, for the bookmaps that my reference glue.sas code uses, it appears that</li><li>forms are B for Breach and A (for non-breach... or "normal' fall, spring summar administrations.</li></ol></li><li>in older commented out code: was used:<ol><li>&#160;OE_* - some such varnames were used in commented-out code, but not elsewhere here in glue.sas</li><li>The other vars are probably used by other BookmapReader() callers</li></ol></li></ol></li></ol></li><li>/*%safeexcelread(filename=&amp;Diocese_File,sheetname=sheet1,DS_out=Diocese, err_var_name=my_err);*/<ol><li>above commented out</li></ol></li><li>/*%safeexcelread(filename=&amp;agg_file,sheetname=conversion,DS_out=Conversion_table, err_var_name=my_err);*/<ol><li>above commented out&#160;</li><li>Next - convert some excel sheets in agg_file into tables for use by "Means"</li><li>-</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=Info,DS_out=info_table, err_var_name=my_err);<ol><li>Created DS info_table from agg file sheet Info_DS</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=Means,DS_out=Mean_table, err_var_name=my_err);<ol><li>Created DS &#160;Mean_table from agg file sheet Means_DS</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=Percent,DS_out=Percent_table, err_var_name=my_err);<ol><li>Created DS Percent_table from agg file sheet Percent_DS</li></ol></li><li>/*%safeexcelread(filename=&amp;agg_file,sheetname=district_conversion,DS_out=district_conversion, err_var_name=my_err);*/<ol><li>commented. out but maybe run earlier?</li></ol></li><li>/*%safeexcelread(filename=&amp;agg_file,sheetname=school_conversion,DS_out=school_conversion, err_var_name=my_err);*/<ol><li>commented</li></ol></li><li>/*%safeexcelread(filename=&amp;cnty_name_file,sheetname=sheet1,DS_out=County_Names, err_var_name=my_err);*/<ol><li>commented</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=ttest,DS_out=ttest_table, err_var_name=my_err);<ol><li>created DS ttest_table</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=cascade,DS_out=cascade_table, err_var_name=my_err);<ol><li>created DS cascade_table</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=Peercompare,DS_out=peer_table, err_var_name=my_err);<ol><li>created DS peer_table</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=suppression_district,DS_out=supp_district, err_var_name=my_err);<ol><li>created DS supp_district</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=suppression_state,DS_out=supp_state, err_var_name=my_err);<ol><li>created DS supp_state</li></ol></li><li>%safeexcelread(filename=&amp;agg_file,sheetname=suppression_school,DS_out=supp_school, err_var_name=my_err);<ol><li>Created DS supp_school</li><li>So did all of: read agg sheets into datasets : ttest_table, cascade_table, peer_table, supp_district, supp_state, supp_school</li></ol></li><li>Options NOMprint;<ol><li>Next - Declare the macro OGT()</li></ol></li><li>%macro OGT(inputds=);<ol><li>Start Macro OGT - covers through line 563</li></ol></li><li>&#160; &#160; Data _null_;<ol><li>Data statement lines 64-67</li></ol></li><li>&#160; &#160; &#160; &#160; set info_table;<ol><li>Set some "ContentStrand_*" variables from the info_table, which is from the info sheet</li></ol></li><li>&#160; &#160; &#160; &#160; call symput("ContentStrand_"||strip(subject),contentstrand);<ol><li>Did set new varname "ContentStrand_X" to info_table's value of &#160;'contentstrand'?</li><li>agg file's info sheet (and so also info_table) &#160;has rows with Subject, contentStrand values:<ol><li>R, A R L I X<ol><li>Now macro variable "ContentStrand_R" has value "A R L I X"</li></ol></li><li>M "M G D N A X"</li><li>S, "P L E S X"</li><li>C, "M E S H X"</li><li>W, "P C A X"</li></ol></li><li>So input dataset info_table row 1 set &#160;var: ContentStrand_R = "A R L I X" , and so on for other rows.</li></ol></li><li>&#160; &#160; run;<ol><li>Did run the Data stmt of line 64 which set varnames: "ContentStrand_{subject}.contentstrand from the info_table</li></ol></li><li>&#160; &#160; /*Reading the input and creating a grade variable with a value of 10 to make the conversion easy*/</li><li>&#160; &#160; Data OGT_data output.ogt_Galludet;<ol><li>Data stmt covers to line 69-85</li><li>This reads the inputds parameter and outputs:<ol><li>" OGT_data_output.ogt_Galludet"&#160;</li><li>and below on line 78 &#160;also to &#160;output OGT_data</li></ol></li><li>It does some changes for diocese schools (JVS), composes full student name.. more</li></ol></li><li>&#160; &#160; &#160; &#160; set &amp;inputds.;&#160;<ol><li>inputds is a - Param from macro OGT declaration on line 57</li><li>line 572 calls this with inputds= input.ogt</li><li>and input is defined above on line x &#160;as:&#160;<ol><li>libname input "H:\share\Ohio Graduation Tests\Technical\2012&#160;October\ScoreReports\PostComplimentaryMergeData";</li></ol></li></ol></li><li>/*if ufxx_SAMPLE=1;*/</li><li>&#160; &#160; &#160; &#160; Student_Name=Cats(ucrxfnm,studentmid,ucrxlnm);<ol><li>Did set Student_Name to concatentation of &#160;first, middle, last names from OGT Macro parameter &#160;inputds,&#160;</li><li>assign dob,&#160;</li><li>delete some records with no attempts,&#160;</li><li>to Galludet, push rows only with b and d ids 1-3 with leading zeroes.</li><li>-</li></ol></li><li>&#160; &#160; &#160; &#160; schtype=schtype_attend;</li><li>&#160; &#160; &#160; &#160; distrtype=distrtype_attend;</li><li>/*Changes for some diocose schools(JVS)*/</li><li>ucrxfnm=compbl(ucrxfnm);<ol><li>SAS function compbl() -&#160;<strong>Removes multiple blanks from a character string.</strong></li></ol></li><li> &#160; &#160;ucrxlnm=compbl(ucrxlnm);<ol><li>removed multiple blanks from first and last names</li></ol></li><li>&#160; &#160; &#160; &#160; if not missing(dob_month) and not missing(dob_day) and not missing(dob_year) then&#160;</li><li>&#160; &#160; &#160; &#160; birthdate=put(dob_month,z2.)||"/"||put(dob_day,z2.)||"/"||put(dob_year,$4.);<ol><li>Did compose and set birthdate from other vars</li></ol></li><li>/*Test purpose*/</li><li>/* &#160; &#160; &#160; &#160;if ufxx_SAMPLE=2;*/</li><li>&#160; &#160; &#160; &#160; if ufrx_Attempt=0 and ufmx_Attempt=0 and ufsx_Attempt=0 and ufcx_Attempt=0 and ufwx_Attempt=0 then delete;<ol><li>We did &#160;not output rows if no Attempt is set for any subject(r,m,s,c,w)- because the 'delete' command skips such rows</li></ol></li><li>if &#160;bcrxid_attend in ("000001","000002","000003") or dcrxid_attend in ("000001","000002","000003") then output output.ogt_Galludet;<ol><li>shuttle rows for three special school codes to Galludet</li></ol></li><li>&#160; &#160; &#160; &#160; else output OGT_data;<ol><li>other rows, put output here is OGT_data, &#160;from argument inputds on line 57</li></ol></li><li>&#160; &#160; run;<ol><li>Ran - Data stmt of line 69-85 to produce output Datasets for OGT_Galludet and OGT_data.</li></ol></li><li>/*temp:Merge distrtype_home dcrxnm_home schtype_home bcrxnm_home form master_list file*/<ol><li>Start commented temp code&#160;</li></ol></li><li>/* &#160; &#160;data master_list;*/</li><li>/* &#160; &#160; &#160; set intake.master_list;*/</li><li>/*run;*/</li><li>/*proc sort data=OGT_data;*/</li><li>/*by dcrxid_home;*/</li><li>/*run;*/</li><li>/*proc sort data=master_list out=mast_list1(rename=(dcrxid_c=dcrxid_home distrtype=distrtype_home dcrxnm=dcrxnm_home)) nodupkey;*/</li><li>/*by dcrxid_c;*/</li><li>/*run;*/</li><li>/*data merge_master1 ;*/</li><li>/*merge OGT_data(in=a) mast_list1;*/</li><li>/*by dcrxid_home;*/</li><li>/*if a;*/</li><li>/*run;*/</li><li>/*proc sort data=merge_master1;*/</li><li>/*by bcrxid_home;*/</li><li>/*run;*/</li><li>/*proc sort data=master_list out=mast_list2(rename=(bcrxid_c=bcrxid_home schtype=schtype_home bcrxnm=bcrxnm_home)) nodupkey;*/</li><li>/*by bcrxid_c;*/</li><li>/*run;*/</li><li>/*data merge_master2;*/</li><li>/*merge merge_master1(in=a) mast_list2;*/</li><li>/*by bcrxid_home;*/</li><li>/*if a;*/</li><li>/*run;*/</li><li>&#160; &#160; /*temp-------------end----------------------------------------------------------------*/<ol><li>end commented temp code</li></ol></li><li>&#160; &#160; %safeexcelread(filename=&amp;datalayout,sheetname=sheet1,DS_out=input_layout, err_var_name=my_err);<ol><li>Did: &#160;read the &amp;datalayout_sheetname into DS input_layout</li></ol></li><li>&#160; &#160; Proc Sql noprint;<ol><li>Get all vars from layout of &#160;type nominal or nominal_id1 into "varlist, used in call to convert_to_dotmissing() on line 119</li></ol></li><li>&#160; &#160; &#160; &#160; select variable_name into: varlist separated by " "</li><li>&#160; &#160; &#160; &#160; from input_layout where (upcase(type)="NOMINAL" and strip(min) ne "" and strip(max) ne "") or (upcase(type)="NOMINAL_ID1") ;</li><li>&#160; &#160; quit;<ol><li>Did: Set "varlist" of &#160;input_layout &#160;row values on column "variable_name" with&#160;<ol><li>(1) type NOMINAL and min and max are set</li><li>&#160;or (2) type NOMINAL_ID1</li></ol></li><li>&#160;-- indicating... well the varlist is used next as an arg to convert_to_dotmissing which seems to set missing values.</li><li>-</li></ol></li><li>&#160; &#160; %convert_to_dotmissing(inputlib=work, inputds=OGT_data, outputds=OGT_data_WithDotM, varlist=&amp;varlist.);<ol><li>inputds OGT_data is produced in line 69 Data step from inputds.</li><li>macro convert_to_dotmissing was included on line 14</li><li>That call did: converted input OGT_data to OGT_data_WithDotM.</li><li>and the function used var list = &amp;varlist (see line 115 for &amp;varlist) -</li><li>And OGT_data_WithDotM is used as input in next call to produce outData = OGT_Propcase</li></ol></li><li>&#160; &#160; %lib_properCase(inData=OGT_data_WithDotM, varNameList=/*bcrxnm_attend dcrxnm_attend dcrxnm_home*/ dcxx_county ucrxfnm ucrxlnm, outData=OGT_Propcase, maxRomanValue=10, romanOutData=tmp)<ol><li>Input is OGT_Data from line,&#160;</li><li>Output is OGT_Propcase</li><li>From line 21 include: &#160;lib_properCase is in .../ScoreReportMacros/UnitTested Macros&#160;</li><li>Create DS OGT_Propcase with names normalized, the O'Hara changed to OHara, similar tweaks.</li><li>OGT_Propcase is used&#160;<ol><li>in line 135 to produce out ds "student"&#160;</li><li>but NOT in line 129 Proc Sql to produce output table "Student"-- it is commented out there.</li></ol></li></ol></li><li>&#160; &#160;/*County problem &#160;is solved in the intake code*/;<ol><li>Skip more commented-out code through line 133</li></ol></li><li>&#160; &#160;/* Proc Sort data=county_names(keep=dcrxid oeds_cty) nodupkey;</li><li>&#160; &#160; &#160; &#160; by dcrxid;</li><li>&#160; &#160; run;</li><li>&#160; &#160; Data county_name;</li><li>&#160; &#160; &#160; &#160; set county_names;</li><li>&#160; &#160; &#160; &#160; dcrxid_C=put(dcrxid,Z6.);</li><li>&#160; &#160; run;</li><li>&#160; &#160; Proc Sql noprint;</li><li>&#160; &#160; &#160; &#160; Create table Student as</li><li>&#160; &#160; &#160; &#160; select A.*,B.OEDS_CTY as dcxx_county1&#160;</li><li>&#160; &#160; &#160; &#160; from ogt_propcase A left join county_name B on (A.dcrxid_attend=B.dcrxid_C)</li><li>&#160; &#160; &#160; &#160; order by lithocode;</li><li>&#160; &#160; quit;*/<ol><li>end commented-out intake code does county names, so not done here (anymore).</li><li>-</li></ol></li><li>proc sort data=ogt_propcase out=student;<ol><li>input dataset ogt_propcase genned in lib_properCase() &#160;from line 120</li><li>outut dataset is student</li></ol></li><li>by lithocode;</li><li>run;<ol><li>Did run of proc of line 134</li><li>&#160;From DS ogt_propcase, we did OUTPUT DS &#160;'student', sorted by lithocode.</li></ol></li><li>&#160; &#160; /*Creating a studentlevel dataset after checking the scalescore and levels*/</li><li>&#160; &#160; /* Creates 3 other tables which will have records that conflict the rules*/<ol><li>Note: 3 output tables will show unruly data.</li></ol></li><li>&#160; &#160; Data output.Student/*(drop= rename=(dcxx_county1=dcxx_county))*/ student_dummy/*(drop= rename=(dcxx_county1=dcxx_county))*/;<ol><li>start lines 139-308: This Data step covers through line 308</li><li>Data statement to create DS outputs139- named<ol><li>&#160;"output.Student"&#160;</li><li>&#160;and student_dummy&#160;</li><li>with some minor column name additions, value changes,<ol><li>&#160;biggest is myid=lithocode</li></ol></li></ol></li><li>from input &#160;DS Student (line 141)</li><li>-change missing grade to 99</li><li>-Has a good amount of data massaging to produce a nice output dataset Student.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; set Student/*_With_DioceseInfo*/ /*(drop= dcxx_county)*/;<ol><li>Did set input from dataset student, generated on line 135 from proc sort.</li></ol></li><li>/* &#160; &#160; &#160; &#160; &#160; &#160;retain count 0;*/</li><li>&#160; &#160; &#160; &#160; myid=lithocode;<ol><li>lines 142-155: create var names like g_xxid from grade, underbar, xxid value</li></ol></li><li>&#160; &#160; &#160; &#160; bcrxid=bcrxid_attend;</li><li>&#160; &#160; &#160; &#160; dcrxid=dcrxid_attend;</li><li>&#160; &#160; &#160; &#160; bcrxnm=bcrxnm_attend;</li><li>&#160; &#160; &#160; &#160; dcrxnm=dcrxnm_attend;</li><li>schtype=schtype_attend;</li><li>distrtype=distrtype_attend;</li><li>&#160; &#160; &#160; &#160; if grade=. then grade=99;</li><li>&#160; &#160; &#160; &#160; rgrade=grade;</li><li>&#160; &#160; &#160; &#160; scrxid=1;/*Creating a stateid for aggregations*/</li><li>&#160; &#160; &#160; &#160; dummy_record_flag=0;</li><li>&#160; &#160; &#160; &#160; g_dcrxid=strip(grade)||'_'||strip(dcrxid);</li><li>&#160; &#160; &#160; &#160; g_bcrxid=strip(grade)||'_'||strip(bcrxid);</li><li>&#160; &#160; &#160; &#160; g_scrxid=strip(grade)||'_'||strip(scrxid);<ol><li>lines 142-155: created var names like g_xxid from grade, underbar, xxid value</li><li>START commented out code . . . through line 163</li></ol></li><li>/* &#160; &#160; &#160; &#160;if bcrxid_attend="999999" then do;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160;count=count + 1;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160;g_bcrxid=strip(grade)||'_'||"999"||strip(put(count,z3.));*/</li><li>/* &#160; &#160; &#160; &#160;end;*/</li><li>&#160; &#160; &#160; &#160; /*Solve spring 2009 apostrophe problem*/</li><li>/*if bcrxid_attend='000652' then bcrxnm_attend=substr(dcrxnm_attend,1,20);*/</li><li>&#160; &#160; &#160; &#160; /*Creating Writing Prompts*/</li><li>&#160; &#160; &#160; &#160; if missing(upwx_OE_Final_1) then Writing_Prompt1=put(upwx_OE_Final_1,$1.);<ol><li>SAS function missing() -&#160;<ol><li>ex-<ul style="margin-bottom: 0px; margin-left: 0px; margin-top: 0px; font-family: arial, 'Arial Unicode MS', geneva, 'Lucida Grande', sans-serif; list-style-image: none; list-style-type: disc; padding-left: 2.5em; font-size: 13.513513565063477px;"><li style="margin-bottom: 4px;"><p style="margin: 1.4em 0px 0px; padding: 0px; border: 0px; font-size: 13.513513565063477px; line-height: 1.25em;"><a name="a000844687" style="margin: 0px; padding: 0px; border: 0px; font-size: 13.513513565063477px; line-height: 1.25em; font-family: inherit;">&#160;</a>The MISSING function checks a numeric or character expression for a missing value, and returns a numeric result. If the argument does not contain a missing value, SAS returns a value of 0. If the argument contains a missing value, SAS returns a value of 1.</p></li><li style="margin-bottom: 4px;"><p style="margin: 1.4em 0px 0px; padding: 0px; border: 0px; font-size: 13.513513565063477px; line-height: 1.25em;">A numeric expression is considered missing if it evaluates to a numeric missing value: ., ._, .A, ..., .Z.</p></li><li style="margin-bottom: 4px;"><p style="margin: 1.4em 0px 0px; padding: 0px; border: 0px; font-size: 13.513513565063477px; line-height: 1.25em;">A character expression is considered missing if it evaluates to a string that contains all blanks or has a length of zero.</p></li></ul></li><li>-Set Writing_Prompt1 to same 'missing' value as upwx_OE_Final_1</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; else Writing_Prompt1="";<ol><li>special value setting/recoding</li></ol></li><li>&#160; &#160; &#160; &#160; if missing(upwx_OE_Final_4) then Writing_Prompt2=put(upwx_OE_Final_4,$1.);<ol><li>if &#160;missing ... so set Writing_Prompt2 to 1-character value in upwx_OE_Final..</li></ol></li><li>&#160; &#160; &#160; &#160; else Writing_Prompt2="";<ol><li>special value setting/recoding to empty string if OE_Final_4 is not missing.. not sure why yet.</li></ol></li><li>&#160; &#160; &#160; &#160; If ufwx_attempt=0 then do;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; writing_prompt1="";</li><li>&#160; &#160; &#160; &#160; &#160; &#160; writing_prompt2="";</li><li>&#160; &#160; &#160; &#160; end;<ol><li>did special writing_prompt settings</li></ol></li><li>&#160; &#160; &#160; &#160; ucxxpon=1;</li><li>&#160; &#160; &#160; &#160; %let subject_list2=R M W SC So;<ol><li>NOTE: this subject_list2 is only used to set var subject2, and that var is not used elsewhere in glue.sas,</li></ol></li><li>&#160; &#160; &#160; &#160; tmp_ucrotherdnp="M W S C";</li><li>&#160; &#160; &#160; &#160; tmp_ucmotherdnp="R W S C";</li><li>&#160; &#160; &#160; &#160; tmp_ucwotherdnp="R M S C";</li><li>&#160; &#160; &#160; &#160; tmp_ucsotherdnp="R M W C";</li><li>&#160; &#160; &#160; &#160; tmp_uccotherdnp="R M W S";<ol><li>set special var for each subject containing &#160;each subject-initial for each 'otherdnp' subject.</li><li>what is dnp?</li></ol></li><li>&#160; &#160; &#160; &#160; length ucrotherdnp ucmotherdnp ucwotherdnp ucsotherdnp uccotherdnp $15.;<ol><li>SAS length statement: the end of the the line &#160;has a $ followed by &#160;the number of bytes for storing variables named previously on the line.</li></ol></li><li>&#160; &#160; &#160; &#160; array tmp_otherdnp(*) tmp_ucrotherdnp tmp_ucmotherdnp tmp_ucwotherdnp tmp_ucsotherdnp tmp_uccotherdnp;<ol><li>sas array statement url&#160;<a href="http://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a000201956.htm">http://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a000201956.htm</a><ol><li>(*) tells SAS to use the dimension as the count of subsequently named variables on the line.</li></ol></li><li>Define and populate convenience array tmp_otherdnp() &#160;of otherdnp lists for subjects r,m,w,s,c in order</li></ol></li><li>&#160; &#160; &#160; &#160; array otherdnp(*) &#160;ucrotherdnp ucmotherdnp ucwotherdnp ucsotherdnp uccotherdnp;<ol><li>Just set similar convenience array for five uc*otherdnp variables</li></ol></li><li>&#160; &#160; &#160; &#160; Reported_Flag=0;</li><li>&#160; &#160; &#160; &#160; /*Scanning through different subjects*/</li><li>&#160; &#160; &#160; &#160; Pass_Count=0;</li><li>&#160; &#160; &#160; &#160; %let i=1;</li><li>&#160; &#160; &#160; &#160; %do %while (%scan(&amp;subject_list,&amp;i) ne);<ol><li>start i loop &#160;over subjects, &#160;through 5 subjects in index 'i'</li><li>covers through line 218,</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let subject=%scan(&amp;subject_list,&amp;i);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let subject2=%scan(&amp;subject_list2,&amp;i);</li><li><ol><li>subject_list (line 32) has R M W S C</li><li>subject_list2 (line 173) has R M W Sc So - Some different abbreviations, but in same order</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if uf&amp;subject.x_attempt=1 and uf&amp;subject.x_invalid eq 0 then Reported_Flag=1;<ol><li>Did set Reported_Flag when input row for &amp;subject has 1 attempt and not invalid.</li><li>It is just a setting to &#160;mirror &#160;in python code version</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /*Creating Accomodation flag for each subject*/<ol><li>create new column for accomodation flag for this subject dep on sub-accom variables</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if &#160;up&amp;subject.x_READ_ALOUD = 1 or</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.x_EXTENDED = 1 or</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.x_DICTIONARY = 1 or</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.x_SCRIBE = 1 or</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.x_CALCULATOR = 1 or</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;up&amp;subject.x_SMALL_GROUP = 1 or*/</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.x_OTHER = 1 then</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; uf&amp;subject.x_accom = 1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; uf&amp;subject.x_accom = 0;<ol><li>Created Accomodation flag per subject,</li><li>and next unset other vals per subject..</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; /*Creating IEP and LEP flags*/<ol><li>create new 'summary' variables for IEP and LEP&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; if upxxlep=1 then up&amp;subject.xlep = 1;else up&amp;subject.xlep = 0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if upxxiep=1 then up&amp;subject.xiep = 1;else up&amp;subject.xiep = 0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.xpscal=.;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.xplev=.;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; up&amp;subject.xmerged=.;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if up&amp;subject.xlev &#160;in (3 4 5) then Pass_count=Pass_count + 1;<ol><li>Adjusted Pass_count, dep on subject.xlev</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if up&amp;subject.xlev &#160;in (3 4 5) then up&amp;subject.xpass=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if up&amp;subject.xlev &#160;in (1 2) then up&amp;subject.xpass=2;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else up&amp;subject.xpass=3;<ol><li>Adjusted xpass dep on xlev</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if up&amp;subject.xlev &#160;in (1 2) or uf&amp;subject.x_attempt=0 &#160;or uf&amp;subject.x_invalid=1 then ucxxpon=0;<ol><li>Adjusted ucxxpon dep on other vars</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if up&amp;subject.xlev &#160;in (3 4 5) or uf&amp;subject.x_attempt=0 &#160;or uf&amp;subject.x_invalid=1 then do;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; do k=1 to 5;<ol><li>start k loop over 'tmp_otherdnp' variables</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tmp_otherdnp(k)=tranwrd(tmp_otherdnp(k),"&amp;subject","");<ol><li>tranwrd(): replaces or removes all occurences of a word in an expression</li><li>tranwrd(source, target, replacement)</li><li>here from tmp_otherdnp(k) we find target subject and replace it with empty string ""</li><li>ISSUE: so why is that done...?<ol><li>So now the current subject at &#160;i &#160;is NOT in its ANY tmp_otherdnp list of other subjects.&#160;</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; end;<ol><li>end k loop at 213 over subjects for setting tmp*dnp(k) vars.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; end;<ol><li>end clause &#160;at&#160;at 212 for xlev in 3,4,5</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let i=%eval(&amp;i+1);</li><li>&#160; &#160; &#160; &#160; %end;<ol><li>end i loop over subjects (i) at line 185 .</li></ol></li><li>&#160; &#160; &#160; &#160; do k=1 to 5;<ol><li>start k do-loop over subjects abbreviations through line 232</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; if length(compress(tmp_otherdnp(k)))=0 then otherdnp(k)="";<ol><li>Set otherdnp(k) to empty if tmp_otherdnp(k) is has only blanks.</li><li>-</li><li>SAS function compress() removes from src string in arg1 all blank chars, or if 2d argument is given, it removes those chars.</li><li>Here if &#160;return value of &#160;length( compress . . .) is 0, src string had no non-blank chars.</li><li>Theory: DNP may stand for "Did not (yet) Process" ?</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; else if length(compress(tmp_otherdnp(k)))=1 then otherdnp(k)=tmp_otherdnp(k);<ol><li>so if only a single nonblank (subject abbreviation letter) in tmp_otherdnp, set otherdnp(k) to it.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; else if length(compress(tmp_otherdnp(k)))=2 then otherdnp(k)=substr(compress(tmp_otherdnp(k)),1,1)||", "||substr(compress(tmp_otherdnp(k)),2,1);<ol><li>SAS substr returns string at pos of arg2 (in SAS, first pos is '1') of length of arg3</li><li>So here, exactly 2 'other' subjects remain in tmp_otherdnp.... in which case it:<ol><li>This just copies the two subject-abbreviation &#160;chars in tmp_otherdnp(k) to otherdnp(k)&#160;</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; else if length(compress(tmp_otherdnp(k)))=3&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; then otherdnp(k)=substr(compress(tmp_otherdnp(k)),1,1)||", "||substr(compress(tmp_otherdnp(k)),2,1)||", "||substr(compress(tmp_otherdnp(k)),3,1);<ol><li>as prior case, but copy 3 subject-abbreviation chars here</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; else if length(compress(tmp_otherdnp(k)))=4&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; then otherdnp(k)=substr(compress(tmp_otherdnp(k)),1,1)||", "||substr(compress(tmp_otherdnp(k)),2,1)||", "||</li><li>&#160; &#160; &#160; &#160; &#160; &#160; substr(compress(tmp_otherdnp(k)),3,1)||", "||substr(compress(tmp_otherdnp(k)),4,1);<ol><li>as prior case, but copy the &#160;4 'other' subject letter chars here</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; otherdnp(k)=tranwrd(otherdnp(k),"C","XX");<ol><li>-SAS function tranwrd(str_source, str_find, str_replace)</li><li>so, in otherdnp(), replace any C with an XX (temporary change to not mess up next change, apparently)</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; otherdnp(k)=tranwrd(otherdnp(k),"S","Sc");<ol><li>otherdnp(k) - set it to the and 'S' to the 'Sc' style of abbreviation</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; otherdnp(k)=tranwrd(otherdnp(k),"XX","So");<ol><li>set otherdnp for orig 'S' in line 229 to the 'So' style for social studies</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; otherdnp(k)=compress(otherdnp(k));<ol><li>final compress to remove any stray blank chars in otherdnp.</li><li>now otherdnp has the 'style2' abbreviations vs the tmp_otherdnp() array.</li></ol></li><li>&#160; &#160; &#160; &#160; end;<ol><li>end k loop over subjects, of line 219-232</li><li>That loop did: scanned the otherdnp values and compressed them... and ...put the style2 abbeviations there.<ol><li>ISSUE: Where is this used?</li></ol></li><li>review: SAS compress() function simply removes chars:s=compress("hello","l)" returns s="heo".</li><li>-</li></ol></li><li>&#160; &#160; /*Scanning through different subjects*/</li><li>&#160; &#160; &#160; &#160; %let i=1;</li><li>&#160; &#160; &#160; &#160; %do %while (%scan(&amp;subject_list,&amp;i) ne);<ol><li>Start i loop &#160;235-298, over 5 subjects : &amp;sub_char,&#160;</li><li>where &#160;subject_list was set at line 32&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let sub_char=%scan(&amp;subject_list,&amp;i);<ol><li>Did set sub_char to a subject in subject_list[i] &#160;of &#160;(R M W S C)</li></ol></li><li>&#160; &#160; /*Scanning through the contentstrand for each subject*/</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let level_vars=;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let Ldum1 =;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let Ldum2 =;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let Ldum3 =;&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let Ldum4 =;&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let j=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %do %while (%scan(&amp;&amp;contentstrand_&amp;sub_char.,&amp;j) ne);<ol><li>j loop over contentstrand_{S}[j]: ie &#160;(non-null) content strand for subject "i" of &#160;&amp;sub_char, jth item contentstrand abbreviation</li><li>covers 244-256.</li><li>This uses index j, while the while(xx,ne) satisfies "ne", is not zero,&#160;</li><li>That is, while the "j" index exists in the contentstrand_{S} string... OK.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let cs=%scan(&amp;&amp;contentstrand_&amp;sub_char.,&amp;j);<ol><li>j index exists, so set cs to the jth contentstrand value for the subject, as set above in line 60.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %If &amp;CS. ne X %then %do;<ol><li>Process a normal content strand value (not the X or 'all' special strand value)</li></ol></li><li>/* &#160; &#160; &#160; &#160; &#160;Options Symbolgen;*/</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let Level_Vars=&amp;Level_Vars up&amp;sub_char.&amp;cs.lev;<ol><li>Did append varname to Level_vars<ol><li>Appended &#160;to it a variable name of the form: up{S}{CS}lev</li><li>Eg, for subject R, strand A it appended var name "upralev"</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let Ldum1 = &amp;Ldum1. &#160; &#160;up&amp;sub_char.&amp;cs.dum1;<ol><li>append var names to Ldum1 like up{S}{C}dum1</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let Ldum2 = &amp;Ldum2. &#160; &#160;up&amp;sub_char.&amp;cs.dum2;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let Ldum3 = &amp;Ldum3. &#160; &#160;up&amp;sub_char.&amp;cs.dum3;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let Ldum4 = &amp;Ldum4. &#160; &#160;up&amp;sub_char.&amp;cs.dum4;<ol><li>Did append to Ldum[1-4] vars another value like: &#160;up{S}{CS}dumN</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;<ol><li>end j-loop of line 244-253 for 'real' content strands</li><li>Var strings LdumN &#160;were &#160;appended with names like (upRAdumN, upRLdumN, etc)</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let j=%eval(&amp;j+1);<ol><li>incremented &#160;j content strand index</li></ol></li><li>/* &#160; &#160; &#160; &#160; &#160;Options NoSymbolgen;*/</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %end;&#160;<ol><li>end j loop of line 244-256 over content strands (unless CS is special 'X" for all)</li><li>created Level_vars at line 248 -list of varnames like: up{S}{C}lev</li><li>created:% Ldum1[*] = &#160;list of names of the form: up{S}{CS}.dum1 ... for this S and every CS in it.</li><li>also created similar %vars named &#160;Ldum2-4: with same makeup..&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array level&amp;sub_char.[*] &amp;Level_Vars;<ol><li>Created convenience/alias array &#160;level{S}[*] for Level_Vars items/names declared/accumulated at line 248.</li><li>holding vars named like up{S}{CS}lev - for just this {S}</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array ldum1&amp;sub_char.[*] &amp;Ldum1;<ol><li>create array ldum1{S}[*] for Ldum1 vars accumulated at line 249 (* is over contentstrands), but all for this subject ( subject loop &#160;is lines 235-298)</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array ldum2&amp;sub_char.[*] &amp;Ldum2;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array ldum3&amp;sub_char.[*] &amp;Ldum3;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array ldum4&amp;sub_char.[*] &amp;Ldum4;<ol><li>created arrays named &#160;LdumN{S} to hold the ldum1 vars that hold up{S}{CS}dumN variable names, contrained to the current {S} loop value, over all CS values.</li><li>so now an index/list for each subject can traverse &#160;all of &#160;a subject's &#160;content strands</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; do i = 1 to %eval(&amp;j-2);&#160;<ol><li>i loop lines 262-277, over real content strands (do not use strand &#160;'x' )</li><li>NB: 'i' is also used in outer loop of lines 235-298, but maybe SAS creates a separate scope for the index in 'do' loops so as to not interfere with the outer 'i'....?</li><li>J was incremented 1 past the N of &#160;content strands at line 254, plus the last one is always 'X', so it is not a real content strand.</li><li>So, that is why i ranges from 1 to j-2, not to j, to range over all content strand indices.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum1&amp;sub_char.[i] =0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum2&amp;sub_char.[i]= 0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum3&amp;sub_char.[i]= 0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum4&amp;sub_char.[i]= 0;&#160;<ol><li>In prior contentstrand loop, we created the variable name arrays for ldum1{S}</li><li>and now we just did set for all of this subjects ldum1 vars for this content strand 'i' ldum1-4{S}[i] = 0&#160;</li><li>This was a handy way to set the constituent variables &#160;assigned to &#160;0 by using the array index 'alias' rather than enumerating each assignment statement.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if level&amp;sub_char.[i] = . then do;<ol><li>However, If the level{s}[i] (array was set at line 257)</li><li>&#160;for this [i] content strand is missing (.) , which it is in here,&#160;</li><li>next &#160;we set the four dum [i] values to missing</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum1&amp;sub_char.[i]= .;&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum2&amp;sub_char.[i]= .;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum3&amp;sub_char.[i]= .;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum4&amp;sub_char.[i]= .;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; end;<ol><li>end clause for missing &#160;level&amp;sub_char [i] of line 267</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if level&amp;sub_char.[i] = 1 then ldum1&amp;sub_char.[i] = 100;<ol><li>here the level{S} for contentstrand[i] is not missing, but it is exactly 1,&#160;</li><li>So set ldum1* to 100</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if level&amp;sub_char.[i] = 2 then ldum2&amp;sub_char.[i] = 100;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if level&amp;sub_char.[i] = 3 then ldum3&amp;sub_char.[i] = 100;<ol><li>In lines 273-275: &#160;one and only one of the ldum{S} 1-3 are set dep on the level{S}[i] value</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if level&amp;sub_char.[i] in (2 3) then ldum4&amp;sub_char.[i] = 100;<ol><li>Separate setting for ldum4{S}[i] - if &#160;level{S} was either 2 or 3, set ldum4{S}[[i] to 100...</li><li>just &#160;because....that's how it is done.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; end;<ol><li>end i &#160;loop at 262-277 over content strands to set LdumN{S}[i] values dep on level{S} [i] values</li><li>Did - initialzed our four 'dum' arrays for this subject over its content strands, and...</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array ldum&amp;sub_char.[5] up&amp;sub_char.xdum1 up&amp;sub_char.xdum2 up&amp;sub_char.xdum3 up&amp;sub_char.xdum4 up&amp;sub_char.xdum5; &#160;<ol><li>set a convenience/alias array of ldum{S}[5] &#160;from var names &#160;up{S}xdum[1-5] with five suffixes xdum1-5</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; do k= 1 to 5;<ol><li>k loop 279-283, start k loop over ldum{S}[1-5] &#160;index values &#160;to address var arrays for &#160;ldumN{S}, ldum{S}, &#160;per line 278</li><li>-</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ldum&amp;sub_char.[k]=0;<ol><li>via array alias of line 278, &#160;init to 0 the vars named in line 278</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if up&amp;sub_char.xlev = . then ldum&amp;sub_char.[k]=.;<ol><li>did set ldum{S}[i] t0 missing if var up{S}xlev has value missing</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if up&amp;sub_char.xlev=k then ldum&amp;sub_char.[k]=100;<ol><li>else if value was k, did set &#160;ldum{S}[k] gets value 100</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; end;<ol><li>end 279-283 &#160;k loop &#160;through indices[1-5] &#160;for vars &#160;ldum{s}[1-5] vars</li><li>NEXT section: lines 284 - 296 :&#160;</li><li>We are back out to main sub_char &#160;loop (234-298)</li><li>Set some new vars profOrHigher{S}, advacc{S}, others.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; if up&amp;sub_char.xlev in (3 4 5) then profOrHigher&amp;sub_char. = 100;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if up&amp;sub_char.xlev in (1 2) then profOrHigher&amp;sub_char. = 0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if up&amp;sub_char.xlev in (. .A) then profOrHigher&amp;sub_char. = .;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if up&amp;sub_char.xlev in (4 5) then advacc&amp;sub_char.=100;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if up&amp;sub_char.xlev in (1 2 3) then advacc&amp;sub_char.=0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if up&amp;sub_char.xlev in (. .A) then advacc&amp;sub_char.=.;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if up&amp;sub_char.xlev in (1 2 ) then BelowProf&amp;sub_char.=100;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else if up&amp;sub_char.xlev in (3 4 5) then Belowprof&amp;sub_char.=0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if up&amp;sub_char.xlev in (. .A) then BelowProf&amp;sub_char.=.;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; InclusionFlag&amp;sub_char.=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if uf&amp;sub_char.x_attempt ne 1 &#160;or uf&amp;sub_char.x_invalid=1 or &#160;Schtype="H" then do;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; inclusionflag&amp;sub_char.=0;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; end;<ol><li>end if at line 292-296</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let i=%eval(&amp;i+1);</li><li>&#160; &#160; &#160; &#160; %end;<ol><li>end i loop at line 235-298 over subjects&#160;</li><li>SCOPE HERE now: at outer scope of this Data step</li></ol></li><li>&#160; &#160; &#160; &#160; if schtype not in ("N" "H" "D") and dummy_record_flag=0 then stateinclusionflag=1;</li><li>&#160; &#160; &#160; &#160; if schtype not in ("N" "H" "C" "U" ) then districtinclusionflag=1;<ol><li>Did set state and district inclusionflags dep on schtype</li></ol></li><li>&#160; &#160; &#160; &#160; Attempt_All=0;</li><li>&#160; &#160; &#160; &#160; if ufrx_attempt=1 and ufmx_attempt=1 and ufwx_attempt=1 and ufsx_attempt=1 and ufcx_attempt=1 then Attempt_all=1;<ol><li>Did set Attempt_all</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; output output.student;&#160;<ol><li>Did &#160;write row to &#160;output goes to output.student</li><li>This seems a complete copy of output dataset student</li></ol></li><li>&#160; &#160; &#160; &#160; If dcrxid_home ne "" then do;<ol><li>Make aux output to student dummy &#160;only for student rows with a given dcrxid_home value.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; dummy_record_flag=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; output Student_dummy;<ol><li>input student_dummy was declared on line 140,&#160;</li><li>The &#160;output dataset Student_dummy datset is almost a copy of &#160;dataset student except:&#160;<ol><li>student_dummy includes only rows where dcrxid_home is not "".</li><li>amd in student_dummy &#160;we set dummy_record_flag to 1, but it is 0 in dataset student.</li></ol></li><li>student_dummy &#160;is used on line 310 in next Data step &#160;student_dummy</li></ol></li><li>&#160; &#160; &#160; &#160; end;<ol><li>end if clause of line 304-307</li></ol></li><li>&#160; &#160; run;<ol><li>end lines 139-308:&#160;Did run &#160; "Data output.Student"&#160;</li></ol></li><li>&#160; &#160; Data student_dummy;<ol><li>Start lines 309-320: &#160;Data &#160;output ds = student_dummy, from input student dummy at line 306</li><li>output is based on student_dummy from line 306, rows where dcrxid != ""...&#160;</li><li>Here we add or overwrite a few new columns&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; set student_dummy;<ol><li>input is student_dummy, from line 306, and here we &#160;modify some columns on output..</li><li>note that columns dummy_flag (not revised here, always 1 set on line 305) , g_dcrxid, g_bcrxid, g_scrxid are used in agg sheet "means".</li></ol></li><li>&#160; &#160; &#160; &#160; dcrxid=dcrxid_home;</li><li>&#160; &#160; &#160; &#160; &#160;dcrxnm=dcrxnm_home;</li><li>&#160; &#160; &#160; &#160; distrtype=distrtype_home;</li><li>&#160; &#160; &#160; &#160; g_dcrxid=strip(grade)||'_'||strip(dcrxid);</li><li>&#160; &#160; &#160; &#160; dcrxnm_attend=dcrxnm_home;</li><li>&#160; &#160; &#160; &#160; bcrxid_attend="";</li><li>&#160; &#160; &#160; &#160; schtype="";</li><li>&#160; &#160; &#160; &#160; g_bcrxid="";</li><li>&#160; &#160; &#160; &#160; g_scrxid=strip(grade)||'_'||strip(scrxid);</li><li>&#160; &#160; run;<ol><li>end lines 309-320: Did run Data student_dummy at line 309</li><li>and added a handful of &#160;vars inited or composed of other vars</li><li>because...</li></ol></li><li>&#160; &#160; Data student_aggregation;<ol><li>lines 321-352</li><li>output dataset is student_aggregation<ol><li>line 354 call : ttest(inputds=student_aggregation... )&#160;<ol><li>which uses both the state and districtinclusionflag, but no item_id/position score items.</li><li>dummy_record_flag usage:&#160;<ol><li>not used as wherevar for the 10 or so district level rows</li><li>IS used as wherevar for the 10 or so school rows, with value 0 &#160;</li></ol></li></ol></li><li>line 356 cascade uses &#160;inputds=student_aggregation</li><li>line 390:dataset student_aggregation is &#160;used by Means():<ol><li>&#160;it does use item-numbered columns with item-numbered item info.</li></ol></li><li>line 395 - Data step uses student_aggregation<ol><li>&#160;and &#160;produces partitions for grade 10-15, 99, eg named student_aggregation_g10, etc..&#160;</li></ol></li><li>line 410: call to PeerCompare(inputds=student_aggregation...) -&#160;<ol><li>but it uses no item data in its agg &#160;sheet peercompare</li></ol></li><li>line 447 (last use): is a mere sort and dup removal to get some unique dcrxids, other ids into dataset 'district':<ol><li>Proc sort data=student_aggregation(where=(strip(dcrxid) ne "") keep= g_dcrxid g_scrxid dcrxid scrxid dcrxnm grade rgrade distrtype) out=district nodupkey;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; by g_dcrxid;</li></ol></li></ol></li><li>lines 321-352 do &#160;basically:&#160;<ol><li>Find the input vars in 2 inputs (output.student and student_dummy)&#160;<ol><li>&#160;that are deemed "released" &#160;in global macro var array MC_Released&#160;</li><li>&#160;and multiply the value of each by 100.</li></ol></li><li>Create vars stateinclusionflag and districtinclusion flag and set them to 0 or 1 based on the input value of schtype (lines 325-326).</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; set output.student student_dummy;<ol><li>INPUT datasets are: (1) output.student and (2) student_dummy, and remember that SAS will read the first one first, then the second one.</li><li>So the output "student_aggregation" does 'aggregate' the two input datsets in a sense (but really appended) , to create the output dataset "student_aggregation"</li><li>Here &#160;DATASET INPUTS &#160;are:,&#160;<ol><li>INPUT1 = &#160;output.student &#160;- see lines 140, 303<ol><li>-Line 303 - basic Student data&#160;</li></ol></li><li>and INPUT2 = student_dummy - see lines 140 and &#160;306<ol><li>-Line 306 - no rows with empty dcrxids, but &#160;same columns (basically) as student_aggregation.</li></ol></li><li>NOTE: per SAS docs, the first dataset is read first, followed by the second.</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; stateinclusionflag=0;</li><li>&#160; &#160; &#160; &#160; districtinclusionflag=0;</li><li>&#160; &#160; &#160; &#160; if schtype not in ("N" "H" "D") and dummy_record_flag=0 then stateinclusionflag=1;<ol><li>did set stateinclusionflag=1, except for schooltypes H=Home, N=? and D=?</li></ol></li><li>&#160; &#160; &#160; &#160; if schtype not in ("N" "H" "C" "U" ) then districtinclusionflag=1;<ol><li>Did set the state, district inclusion flags per schtype value.</li></ol></li><li>/* JVS student with non-public home districts should not be aggregated to the state level(public). */<ol><li>Did state the "JVS &#160;rule" governing aggregation segregation.</li></ol></li><li>if distrtype = "J" and distrtype_home in ("N","D") then stateinclusionflag=0;</li><li>&#160; &#160; &#160; &#160; &#160;/*Scanning through different subjects*/</li><li>&#160; &#160; &#160; &#160; %let i=1;</li><li>&#160; &#160; &#160; &#160; %do %while (%scan(&amp;subject_list,&amp;i) ne);<ol><li>lines 331-342: i loop over subjects</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let sub_char=%scan(&amp;subject_list,&amp;i);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %if &#160;&amp;admin=spring %then %do; &#160; &#160;<ol><li>if clause lines 333-340</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %if (&amp;&amp;MC_Released_&amp;sub_char._A_&amp;grade. ne ) &#160;%then %do;<ol><li>if clause lines 334-339</li><li>MC_Released{S}_A_{G}... is set from BookMapReader() call<ol><li>theory: this means that for this subject all MC items are officially 'released'?</li></ol></li><li>here, admin is spring and MC_Released for subject and grade...&#160;<ol><li>and A is form A, and remember this var was set from BookmapReader from bookmap data...</li></ol></li><li>find prior reference to MC_Released* -- OK, it is set by above call to BookmapReader() on line 44.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; array item&amp;sub_char.(*) &#160;&amp;&amp;MC_Released_&amp;sub_char._A_&amp;grade.;<ol><li>make array item{S}(*) for the MC_Released{S}.... array this this loop's subject. and the overarching &amp;grade.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; do j=1 to dim(item&amp;sub_char.);<ol><li>-start j loop 336-338 over dim() (number of) items for this subject&#160;</li><li>ie, number of varnames like "upW_score_item3, upW_score_item5', . . .&#160;<ol><li>&#160;that exist in MC_Released... array populated by bookmapreader.</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; item&amp;sub_char.(j)=item&amp;sub_char.(j)*100;<ol><li>Multiply &#160;item_{S}(j) value by factor of 100 because . . . just required</li><li>so this is like upW_score_item_3 *= 100 - probably &#160;to make some downstream calculations easier.</li><li>NB:&#160;<ol><li>this assumes that the input dataset HAS the named variable in it, eg upW_score_item_3</li></ol></li><li>NOTE: This does not create such var names, it assumes they are available in the</li><li>input.. and so this is where (or prior to this loop actually) emulation python code needs to:<ol><li>read the sql server 2012 database tables named &#160;MC* per subject for items data,</li><li>and output and cacluate new updated MC* tables with these new variable &#160;values.</li><li>Design ALT A:<ol><li>Aside; consider in python code: just outputting an update table that identifies the subject, item pos, new value - then an sql statement can use it to update input MC* tables or copies of them..</li></ol></li><li>-Design Alt B:&#160;<ol><li>modify design of &#160;python glue function Study. study_ogt() to accept the sas-style full-blown 2K+ column query results dataset with up to 4096 columns that includes the MC &#160;items data for ALL 5 subjects and aliases the sql-server style column names into the old-style sas names....as used in the workbook agg, sheet 'means'.</li><li>this will require some new code to construct the humongous sql query to join all the tables and create the alias column names, but just need a python script utility to generate that query. Then use that to define/initialize the main student input dataset.&#160;<ol><li>Aside: might also develop some support for a 'merge' capability for pre-sorted multiple cvs files that works the same way, off of the 1 'flat' and 5 MC_subject style of cvs-stored datasets pre-sorted. - future possibility.</li></ol></li><li>This will allow direct manipulation of the 'row' dictionary values to modify the variable values, eg to multiply by 100 and to peform a row-level accrue() functionality for the means() (and other stats).</li><li>&#160;A huge speedup. &#160;</li></ol></li><li>Design Alt C:&#160;<ol><li>utility to do an auto-update of the means sheet to relabel the variable names and add a table_name column to create a modified " means_sheet", in keeping with the approach glue.sas does already, to modify its original means_sheet based on MC_released status that may change in the bookmap info files.</li></ol></li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; end;<ol><li>end j loop &#160;of line 336-338</li><li>&#160;j loop over &#160;items for subject of &#160;i loop and given form, grade</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;<ol><li>end if-do clause of line 334-339 - MC items released for this subject not blank</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160;%end;<ol><li>end if-do clause of line 333 - 340 spring admin</li></ol></li><li>&#160; &#160; &#160; &#160; %let i=%eval(&amp;i+1);</li><li>&#160; &#160; &#160; &#160; %end;<ol><li>end i loop &#160;over subjects of &#160;line 331-342. &#160;RECAP:<ol><li>Did: create array item{S}(*) of &#160;&amp;MC_Released_{S}_A_{G} -&#160;<ol><li>where bookmapReader set MC_Released_{S}_A_{G} there --at line. 155 and comments.</li><li>It is an array of 'conststruct' values, ie var names of the form:<ol><li>upRx_score_item_12, for the 'where' conditions of bookmapreader.sas line 158:<ol><li>&#160;where upcase(&amp;BM_itemformat_var)="MC"&#160;</li><li>and upcase(&amp;BM_Role_var.)="OPERATIONAL"&#160;</li><li>and Upcase(&amp;BM_TaggedForRelease_var.)="YES";</li></ol></li></ol></li></ol></li><li>Did: simply multiply the values of those variables times 100, and those are assumed to be actual output variable names in the input and output datasets.</li></ol></li><li>Start - set/recode ethnicity codes for integer level values, &#160;and also set migrant and gender....</li></ol></li><li>&#160; &#160; &#160; &#160; &#160;if &#160;strip(ethnicity)="1" then ethnicity_code='ai';</li><li>&#160; &#160; &#160; &#160; &#160; &#160;else if &#160; &#160;strip(ethnicity)="2" then ethnicity_code='as';</li><li>&#160; &#160; &#160; &#160; &#160; &#160;else if &#160; &#160;strip(ethnicity)="3" then ethnicity_code='af';</li><li>&#160; &#160; &#160; &#160; &#160; &#160;else if &#160; &#160;strip(ethnicity)="4" then ethnicity_code='hs';</li><li>&#160; &#160; &#160; &#160; &#160; &#160;else if &#160; &#160;strip(ethnicity)="5" then ethnicity_code='wh';</li><li>&#160; &#160; &#160; &#160; &#160; &#160;else if &#160; &#160;strip(ethnicity)="6" then ethnicity_code='mu';</li><li>&#160; &#160; &#160; &#160; &#160; &#160;ufxx_migrant=migrant;</li><li>&#160; &#160; &#160; &#160; &#160; &#160;gender=ucrxgen;<ol><li>Did:&#160;set/recode ethnicity codes for integer level values, &#160;and also set migrant and gender</li></ol></li><li>&#160; &#160; &#160; &#160; if schtype ne "H";<ol><li>That skipped all rows where schtype is 'H'. - Home schooled.</li></ol></li><li>&#160; &#160; run;<ol><li>end lines 321-352, "Data student_aggregation" &#160;step</li><li>NB: This is the key input data required for next call to macro ttest() and probably some following macros.</li><li>NB: Python code should also be added to support 'new' sql server data relations, where per-subject tables now exist to hold book_item_position data per item.<ol><li>consider:ALT A - &#160;converting "old-style" of data, revealed by column or var names ending in item number, in agg sheet tttest (and others) to 'new-style':<ol><li>change old-style ttest sheet column of &#160;variable name into 2 columns, 1 for table name or subject and 1 for new variable name</li></ol></li><li>Alt B: -&#160;<ol><li>simply have ttest() use a dataset or sql view that uses the same column names that appear in the ttest sheet, but the view or dataset is structured to join the 'flat and the subject-item' tables properly and provide output column name aliases to match the agg.ttest sheet, so no changes needed in ttest code, others...</li><li>per this link, MAY have up to 4096 columns in a select, so this approach of constructing a select to join the flat table and 5 MC subject* tables should work, using the 'traditional-sas-style' column names.</li><li>just check whether ttest needs more than 1024 columns... ie in the spreadsheet...<ol><li>or &#160;if so - check whether sql server has a 1024 column limit on views... maybe it only applies to tables, and if so, this is fine. -- OK, it has 4096 column limit on selected columns. That will suffice.</li></ol></li></ol></li></ol></li></ol></li><li>&#160; &#160; %put "-------------------------------------ttest start;";</li><li>&#160; &#160; %ttest(excel=N,agg_ds=ttest_table,agg_file=,agg_sheet=,inputds=student_aggregation);<ol><li>Did run macro ttest -&#160;</li><li>DO SEE: &#160;Doc ttest_doc.doc in&#160;C:\CVSProjects\ScoreReportMacros\UnitTested\ttest<ol><li>In that doc p4 of 7 describes the params<ol><li>excel is Y if input is of type Excel or N of it is of type DS</li><li>agg_ds is the input "spec sheet" &#160;DS if excel is N</li><li>-agg_file is the input spec in an &#160;excel file if excel is Y, and agg_sheet is the sheet name</li><li>input ds - the name of the actual input for the ttest call.</li></ol></li><li>p4 describes the columns for the input spec dataset (only 31 rows [ (School,Distrct) * subject (q5) * inputVar(ProfOrHigher{S}, advacc{S}) * ParentLevel(state alone for District,, (state or district for school)] so<ol><li>TargetLevel of Disctrict{S} has 1 * 5 * 2 rows = 10,</li><li>TargetLevel School has 1 * 5 * 2 * 2 = 20</li><li>total rows = 30 + 1 for header</li></ol></li><li><ol><li>outputvar is the name of the output var (computed ttest stat value?)</li><li>input var - eg ScaleScore , on which to base the ttest</li><li>more: --Targetlevel- Name of the target
level (ex- District_R_,School_W, State_M, [Rclass]).No special characters are allowed in this column, as this is
used to create the name of the output dataset.<p>TargetID- Lists the Target ID
variable (Rclass_id).</p><p>WhereT- List of variables separated
by *. This will be used to subset the target level data before any
calculations.</p><p>WhereT_Value- List of values
separated by blank corresponding to the list of variables specified in the
whereT column.</p><p>Parentlevel- Name of the parent
level (examples:Disctrict, State,, School).</p><p>ParentID- Lists the Parent ID
variable (bcrxid).</p><p>WhereP- List of variable separated
by *. This will be used to subset the parent level data before any
calculations.</p><p>WhereP_Value- List of values
separated by blank corresponding to the list of variables specified in the whereP
column.</p></li><li>--if annotate more on ttest, do it here</li></ol></li><li>See all 7 pages in that doc.. very useful succinct documentation</li></ol></li><li>-</li></ol></li><li>%put "-------------------------------------ttest end;";</li><li>&#160; &#160; %cascade(excel=N,agg_ds=cascade_table,agg_file=,agg_sheet=,inputds=student_aggregation);<ol><li>Did run macro cascade--</li><li>-do the processing directed in the agg workbook sheet 'cascade' rows, with columns and row1 values<ol><li>output var: dpraccf</li><li>Subject: R</li><li>Level district</li><li>LevelVar _dcrxid</li><li>InputVar upraraw</li><li>criterion: None</li><li>Wherevar: InclusionFlagR (or "varA * VarB ...)</li><li>Wherevalue; 1 (or: 1 2 . . . )</li></ol></li></ol></li><li>&#160; &#160; %put "-------------------------------------cascade end;";</li><li>&#160; &#160; &#160;Data Mean_OGT (drop=pattern position);<ol><li>Start Data Mean_OGT step lines 358-388</li><li>&#160;to produce output DS Mean_OGT from input Mean_table</li><li>this basically looks at bookmaps and selects the good released MC items</li></ol></li><li>&#160; &#160; &#160; &#160; set Mean_table;<ol><li>input DS Mean_table &#160;created at line 45 from agg_file sheet "Means"</li></ol></li><li>&#160; &#160; &#160; &#160; pattern = prxparse('/_score_item_/');<ol><li>SAS prxparse(): compiles perl regular expression (PRX) into pattern that can be used for pattern matching -&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; call prxsubstr(pattern, inputvar, position);<ol><li>NOTE: "inputvar" is a column of the input Mean_table, sample values:&#160;<ol><li>uprxscal</li><li>uprx_score_item_50, etc...&#160;</li></ol></li><li>-sas doc on prxsubstr(): &#160;url&#160;<a href="http://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a002295971.htm">http://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a002295971.htm</a></li><li>position &gt; 0 means pattern was found in name of inputvar,&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; if position &gt; 0 then do;<ol><li>lines 362-387</li><li>Start if-do: Match of &#160;'_score_item_" was found in inputvar</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160;%let i=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %do %while(%scan(&amp;subject_list,&amp;i.) ne); &#160;<ol><li>Start &#160;i loop through subjects</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let sub_char=%scan(&amp;subject_list,&amp;i.);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let &#160;j=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %do %while(%scan(&amp;&amp;Item_NotReleased_&amp;sub_char._A_&amp;grade , &amp;j.) ne) ;<ol><li>start j loop through items in list of &#160;"Item_NotReleased_{S}_A_{G}[j] list.</li><li>Do ONLY where Item_NotReleased{S}{G} is NULl.</li><li>See line 37 call to BookmapReader set the ItemNotReleased*_A_* value.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let var=%upcase(%scan(&amp;&amp;Item_NotReleased_&amp;sub_char._A_&amp;grade, &amp;j.));<ol><li>var is the upcase value &#160;(ie a up{S}x_score_item_{N}" style variable name) for jth item stored in &#160;this array "ItemNotReleased-- &#160;for this subject and grade" .</li><li>Rem: line 37 call to BookmapReader &#160;is what set the ItemNotReleased*_A_* array with var names</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if upcase(inputvar)="&amp;var." then delete;<ol><li>delete (stop) &#160;processing this row (so do not output a row for it) &#160;if inputvar is in ItemNotReleased* [j].. because ...it seems this Item is "Not Released", so we must not produce output for it.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let j=%eval(&amp;j + 1);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;<ol><li>end j loop of line 366-371 over Item Not released variable names ( item vars) &#160;list</li><li>if here, some item or items for this subject grade , per the Item_NotReleases{S}{G} assertion &#160;were rleased</li></ol></li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let &#160;j=1;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%do %while(%scan(&amp;&amp;OE_Released_&amp;sub_char._A_&amp;grade. , &amp;j.) ne) ;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let var=%upcase(%scan(&amp;&amp;Item_NotReleased_&amp;sub_char._A_&amp;grade, &amp;j.));*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if upcase(inputvar)="&amp;var." then rdvalue=1;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let j=%eval(&amp;j + 1);*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%end;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let &#160;j=1;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%do %while(%scan(&amp;&amp;OE_Released_&amp;sub_char._A_&amp;grade., &amp;j.) ne) ;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let var=%upcase(%scan(&amp;&amp;Item_NotReleased_&amp;sub_char._A_&amp;grade, &amp;j.));*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if upcase(inputvar)="&amp;var." then rdvalue=;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let j=%eval(&amp;j + 1);*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%end;*/</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if upcase(substr(inputvar,3,1))="&amp;sub_char." and substr(strip(inputvar),17)&gt; &#160;&amp;&amp;MaxitemNum_&amp;sub_char._A_&amp;grade. then delete;<ol><li>If got here, inputvar char pos 3 matches current subject and item number not too big</li><li>NOTE: MaxitemNum.*_A_* is set by above call to BookmapReader().</li><li>Here we delete or ignore this input row and do not output a row for it when<ol><li>because the inputvar third position (eg upSx_score_item7) char pos 3 is for current &amp;sub_char subject, say='S' here,&#160;</li><li>AND &#160;beginning at pos 17 must be the item number value&#160;</li><li>and its value exceeds max items for this subject,</li><li>&#160;so guesing it is now deemed bogus and&#160;</li><li>so we delete the row or further processing for it.</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let i=%eval(&amp;i + 1);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %end;<ol><li>end i loop &#160;thru subjects of &#160;line 364</li></ol></li><li>&#160; &#160; &#160; &#160; end;<ol><li>end if-do inputvar has "_score_item_" of line 362-387</li><li>end of &#160;examining all score_item var iable names in 'inputvar' in the MEANS SHEET and keeping only those that are 'released' in output DS "OGT_Mean"</li></ol></li><li>&#160; &#160; run;<ol><li>lines 358-388: Did &#160;Data step to produce DS &#160;Mean_OGT, &#160;a subset of rows from &#160;input Mean_table,<ol><li>Mean_OGT now &#160;has ONLY the inputvar names in its 'sheet'-like dataset that are released.</li><li>&#160;filtering out rows for items not released, or for other rows for which to NOT create MEANS analyses now (item number too high).</li></ol></li><li>We DID: recap:&#160;<ol><li>line 369 we deleted a row where the inputvar matched any 'itemnotreleased' variable name...&#160;</li><li>lin 384 we deleted rows with too-high item numbers...&#160;</li></ol></li><li>So - basically: this simply modified the aggregation workbook sheet for 'means_table' with the set of 'standing analyses' to try to do, and it excluded some rows/analyses to do because Means() uses this output to control its set of analyses.</li><li>--</li></ol></li><li>&#160; &#160; %put "-------------------------------------means start;";</li><li>&#160; &#160; %Means(excel=N,agg_ds=Mean_OGT,agg_file=,agg_sheet=, inputds=student_aggregation,percent=Y, percent_file=, percent_sheet=, percent_ds=percent_table, debug=0);<ol><li>-See Means.doc under&#160;C:\CVSProjects\ScoreReportMacros\UnitTested\Means<ol><li>another fine doc it is&#160;</li><li>agg_ds=Mean_OGT &#160;is input dataset, a spec to calc stats, derived from mean_table in agg workbook &#160;means sheet at line 51, just revised a bit by Data Mean_OGT of &#160;lines 362-288 above</li><li>inputds is student_aggregation-</li><li>percent=Y, so do calculate 'the percentage variable'</li><li>percent_ds=percent_table also a sheet read at line 52, part of &#160;initial agg workbook &#160;at line 34</li></ol></li><li>also see python means code:</li></ol></li><li>&#160; &#160; %put "-------------------------------------means end;";</li><li>&#160; &#160; &#160; %let districtds=mean_g_dcrxid;<ol><li>For origin of variable 'mean_g_dcrxid", see&#160;C:\CVSProjects\ScoreReportMacros\UnitTested\Means.sas --&#160;<ol><li>It is produced by the %means macro (as are mean_g_bcrxid, mean_g_scrxid),&#160;<ol><li>because %Means produces a dataset named mean_xxx for xxx for every levelvar mentioned in the means sheet.</li></ol></li><li>Its top comments say that it outputs variables named &#160;mean_$LevelVar' &#160;for every value in the agg sheet "Means" (now in the dataset "Means_table", see line 51?).</li><li>that Means_table has LevelVar =" g_dcrxid", and so the just-prior Means call genned var name "mean_g_dcrxid", plus many more</li></ol></li></ol></li><li>&#160; &#160; %let schoolds=mean_g_bcrxid;<ol><li>mean_* &#160;are dataset/output file names that are genned by the &#160;Means() call on line 390.</li></ol></li><li>&#160; &#160; %let schoolds2=;</li><li>&#160; &#160; Data student_aggregation_g10 student_aggregation_g11 student_aggregation_g12 student_aggregation_g13 student_aggregation_g14 student_aggregation_g15 student_aggregation_g99;<ol><li>Start Data step for doling out by-grade slices of &#160;INPUTDS="student_aggregation" to multiple OUTPUT DSes = &#160;student_aggregation_g[10,11,12,13,14,15,99]</li><li>covers lines 395-404. run is at line 404</li></ol></li><li>&#160; &#160; &#160; &#160; set student_aggregation;<ol><li>Based on input DS student_aggregation</li></ol></li><li>&#160; &#160; &#160; &#160; if grade=10 then output student_aggregation_g10;</li><li>&#160; &#160; &#160; &#160; else if grade=11 then output student_aggregation_g11;</li><li>&#160; &#160; &#160; &#160; else if grade=12 then output student_aggregation_g12;</li><li>&#160; &#160; &#160; &#160; else if grade=13 then output student_aggregation_g13;</li><li>&#160; &#160; &#160; &#160; else if grade=14 then output student_aggregation_g14;</li><li>else if grade=15 then output student_aggregation_g15;</li><li>&#160; &#160; &#160; &#160; else if grade=99 then output student_aggregation_g99;<ol><li>That distributes the rows per their grade value to the output DSes</li></ol></li><li>&#160; &#160; run;<ol><li>Did run Data at line 395 to create the multiple student_aggregation_g* datasets</li></ol></li><li>&#160; &#160; %let grade_list=10 11 12 13 14 15 99;</li><li>&#160; &#160; %local y;</li><li>&#160; &#160; %let y=1;</li><li>&#160; &#160; %do %while(%scan(&amp;grade_list,&amp;y.) ne);&#160;<ol><li>lines 408-420: start y loop over grades</li></ol></li><li>&#160; &#160; &#160; &#160; %let grade=%scan(&amp;grade_list,&amp;y.);<ol><li>Did set current grade</li></ol></li><li>&#160; &#160; &#160; &#160; %PeerCompare(excel=N, agg_ds=peer_table,agg_file=,agg_sheet=,indata=student_aggregation_g&amp;grade., outdata=District_Peer_&amp;grade., &#160;&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; critval = 1.96,</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; pcdata=similar.similardist);<ol><li>Did run PeerCompare for current &amp;grade to produce output DS=District_Peer_&amp;grade&#160;</li><li>Did call PeerCompare to produce one of many Datasets named District_Peer_&amp;grade</li><li>put outdata to District_Peer_&amp;grade.</li><li>Resume - add doc link here&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; Data District_Peer_&amp;grade.;<ol><li>Data step to revise dataset &#160;District_Peer_&amp;grade - add new column with catted &#160;value for g_dcrxid</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; set District_Peer_&amp;grade.;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; g_dcrxid="&amp;grade._"||strip(dcrxid);</li><li>&#160; &#160; &#160; &#160; run;<ol><li>Did run to append to DS District_Peer_&amp;grade the column "g_dcrxid"</li></ol></li><li>&#160; &#160; &#160; &#160; Proc Append base=peercompare_out data=District_Peer_&amp;grade.;<ol><li>this appends to output ds peercompare_out the catted input data from District_Peer_&amp;grade</li></ol></li><li>&#160; &#160; &#160; &#160; run;<ol><li>Did run to append &#160;peercompare_out ...</li><li>We are in a loop over grades, so this Dataset &#160;peercompare_out will append all peer compare results</li></ol></li><li>&#160; &#160; &#160; &#160; %let y=%eval(&amp;y + 1);</li><li>&#160; &#160; %end;<ol><li>end y loop of line 408-420 over grade levels 10...99</li><li>now output DS "peercompare_out" &#160;has all data from all grades due to call to Append() in line 417</li></ol></li><li>&#160; &#160; Proc sort data=peercompare_out noduprecs;</li><li>&#160; &#160; by g_dcrxid;</li><li>&#160; &#160; run;<ol><li>did remove dups and sort by g_dcrxid the ds "peercompare_out"</li></ol></li><li>&#160; &#160; %local y;</li><li>&#160; &#160; %let y=1;</li><li>&#160; &#160; %do %while(%scan(&amp;subject_list,&amp;y.) ne); &#160;&#160;<ol><li>lines426-432: do y loop through subjects &#160;</li></ol></li><li>&#160; &#160; &#160; &#160; %let sub_char=%scan(&amp;subject_list,&amp;y.);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let districtds=&amp;districtds ttest_district_&amp;sub_char. cascade_district_&amp;sub_char.;<ol><li>set array distrctds items to vars(ds names) &#160;ttest_district_t* and cascade_district* &#160;for this subject.</li></ol></li><li>&#160; &#160; &#160; &#160; %let schoolds=&amp;schoolds &#160;ttest_school_&amp;sub_char. cascade_school_&amp;sub_char.;<ol><li>set array schoolds &#160;to vars &#160;ttest_school_{S} and cascade_school_{S}... over subject in this subject loop</li></ol></li><li>&#160; &#160; &#160; &#160; %let schoolds2= &amp;schoolds2 cascade_district_&amp;sub_char.;<ol><li>append to schoolds2 list &#160;only the var cascade_district_{S} names... because</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; %let y=%eval(&amp;y + 1);</li><li>&#160; &#160; %end;<ol><li>end lines 426-432: &#160;y loop over subjects at line 426</li><li>Now we &#160;have ds name lists in array vars districtds, schoolds and schoolds2</li></ol></li><li>&#160; &#160; &#160;Proc Sql noprint;<ol><li>lines 433-439: create table school as subset of columns and rows of DS "output.student", ordered by g_bcrxid.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; create table school as&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; select distinct g_bcrxid,g_dcrxid,g_scrxid,bcrxid,bcrxnm,grade,rgrade,schtype</li><li>&#160; &#160; &#160; &#160; &#160; &#160; from output.student</li><li>&#160; &#160; &#160; &#160; &#160; &#160; where strip(bcrxid) ne "" and schtype ne "H"</li><li>&#160; &#160; &#160; &#160; &#160; &#160; order by g_bcrxid;</li><li>&#160; &#160; &#160; &#160; quit;<ol><li>lines 433-439: Did Create and &#160;run proc to create narrow table "school" from output_student with bcrxid and non-H schtype, sorted by g_bcrxid (school id)</li></ol></li><li>&#160; &#160; &#160; &#160; Proc Sql noprint;<ol><li>lines 440-446 create outputDS school_intervention subsetted from inputDS output.student</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; create table school_intervention as&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; select distinct bcrxid_attend,bcrxnm_attend,dcrxid_attend,dcrxnm_attend,scrxid,schtype</li><li>&#160; &#160; &#160; &#160; &#160; &#160; from output.student</li><li>&#160; &#160; &#160; &#160; &#160; &#160; where strip(bcrxid_attend) ne "" and schtype ne "H"</li><li>&#160; &#160; &#160; &#160; &#160; &#160; order by bcrxid_attend;</li><li>&#160; &#160; &#160; &#160; quit;<ol><li>lines 440-446: Created narrow ds school_intervention with non-null bcrixid and schtype ne H</li></ol></li><li>&#160; &#160; &#160; &#160; Proc sort data=student_aggregation(where=(strip(dcrxid) ne "") keep= g_dcrxid g_scrxid dcrxid scrxid dcrxnm grade rgrade distrtype) out=district nodupkey;<ol><li>SAS nodupkey: url&#160;<a href="http://support.sas.com/kb/5/030.html">http://support.sas.com/kb/5/030.html</a></li><li>-This assures no dups of g_dcrxid -- I &#160;guess it keeps the first occurence if more than 1...&#160;</li><li>-So maybe this is how the student_dummy rows are discounted in subsequent processing?</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; by g_dcrxid;</li><li>&#160; &#160; &#160; &#160; run;<ol><li>lines 447-448: Created output DS "ds district" (with nodupkey) from input DS "student_aggregation"&#160;<ol><li>from student_aggregation with good dcrxid</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; Proc Sql noprint;<ol><li>create output DS="state" from inputDS "output.student"</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; create table state &#160;as&#160;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; select distinct g_scrxid,grade, rgrade</li><li>&#160; &#160; &#160; &#160; &#160; &#160; from output.student;</li><li>&#160; &#160; &#160; &#160; quit;<ol><li>created very narrow 3-column ds "state" &#160;g_scrxid,grade,rgrade...</li></ol></li><li>&#160; &#160; &#160; &#160; Data output.school_intervention;<ol><li>create outputDS "output.school_intervention" from&#160;<ol><li>input DS1 &#160;'school_intervention' (line 441) (and use indicator inschool variable used for it)</li><li>and input DS2 'mean_bcrxid_attend'</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; merge school_intervention(in=inschool) mean_bcrxid_attend;<ol><li>keyword in:&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; by bcrxid_attend;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; bcrxid=bcrxid_attend;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; bcrxnm=bcrxnm_attend;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; dcrxid=dcrxid_attend;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if inschool;</li><li>&#160; &#160; &#160; &#160; run;<ol><li>lines 455-462: Rewrote ds output.school_intervention by merge in=inschool</li></ol></li><li>&#160; &#160; &#160; &#160; Data school_notsuppressed;<ol><li>lines 463-467</li><li>create output DS "school_notsuppressed" from input datasets:<ol><li>school - created on line 434</li><li>schoolds is array of datasets<ol><li>was set on line 429: -</li><li>schoolds=&amp;schoolds &#160;ttest_school_&amp;sub_char. cascade_school_&amp;sub_char.;&#160;</li><li>One set appended every subject.</li></ol></li><li>-</li></ol></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; merge school(in=inschool) &amp;schoolds;<ol><li>notes on in, in= option&#160;<ol><li>-ex-Specify the IN= data set option in parentheses after a SAS data set name in the SET, MERGE, MODIFY, and UPDATE statements only.&#160;</li><li>excerpt-<ol><li>Values of &#160;IN= variables are available to program statements during the DATA step, but the variables are not included in the SAS data set that is being created, unless they are assigned to a new variable.</li><li>When you use IN= with BY-group processing, and when a data set contributes an observation for the current BY group, the IN= value is 1. The value remains as long as that BY group is still being processed and the value is not reset by programming logic.</li></ol></li></ol></li><li>-</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; by g_bcrxid;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if inschool;</li><li>&#160; &#160; &#160; &#160; run;<ol><li>lines 463-467: created output ds "school_notsuppressed" &#160;where each has a non-null g_bcrxid.?</li><li>-</li></ol></li><li>&#160; &#160; &#160; &#160; Proc Sort data=school_notsuppressed;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; by g_dcrxid;</li><li>&#160; &#160; &#160; &#160; run;<ol><li>lines 468-470: resorted dataset school_notsuppressed by g_dcrxid.</li></ol></li><li>&#160; &#160; &#160; &#160; Data school;<ol><li>lines 471-</li><li>Data REWRITE&#160;&#160;output DS school- covers through line 493</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; merge school_notsuppressed(in=inschool) &amp;schoolds2.;<ol><li>schoolds2 created on line 430 - list of &#160;datasets of cascade-district-data... because...</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; by g_dcrxid;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160;if inschool;<ol><li>continue/output only if &#160;DS 'school_notsuppressed' contributed data to the row</li><li>only schools with bcrxid? it seems-- or inschool?&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array r_items(*) bprxit1-bprxit50;<ol><li>Convenience array: bprxit1-50, FROM datastet/SHEET.. means_table, from sheet of &#160;code line 45.</li><li>See it in excel rows 272 - 321</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array m_items(*) bpmxit1-bpmxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array w_items(*) bpwxit1-bpwxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array s_items(*) bpsxit1-bpsxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array c_items(*) bpcxit1-bpcxit50;<ol><li>more convenience arrays for vars named in Means ds from code line 45 and agg file sheet means.</li><li>these vars are in the means sheet around the middle of the rows: &#160;rows 270-490 or so.</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let m=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %do %while(%scan(&amp;subject_list,&amp;m) ne);<ol><li>lines 480-493: Start m loop through subjects</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let sub_char=%scan(&amp;subject_list,&amp;m);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bp&amp;sub_char.ttest="X";<ol><li>set bp{S}ttest to 'X'&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let i=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %do %while(%length(%scan(&amp;&amp;contentstrand_&amp;sub_char.,&amp;i.)));<ol><li>lines 484- 491start i loop through content strands</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let cs=%scan(&amp;&amp;contentstrand_&amp;sub_char.,&amp;i);<ol><li>set cs to the [i] &#160;contentstrand initial</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %If &amp;CS. ne X %then %do;<ol><li>CS is a 'real' content strand value (that is, not 'X').</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if bp&amp;sub_char.&amp;cs.ccf=1 &#160;and dp&amp;sub_char.&amp;cs.ccf in (2,3) then bp&amp;sub_char.ttest="&amp;CS.";<ol><li>bp{S}{CS}ccf =1 &#160;and db{S}{CS}ccf in (2,3) &#160;- cascade() result output values..<ol><li>if here, we set bp{S}_ttest={CS}- content strand &#160;2-char abbrev or 1?.</li><li>Found the var names in sheet 'cascade' - (see sheetreference code line 51)</li><li>They are cascade output variables,</li><li>&#160;eg sheet &#160;row 26 shows bpmaccf,, a &#160;cascade result for , math, strand A.</li><li>-</li></ol></li><li>So the cascade results&#160;</li><li>so. then .we did set bp{S}.ttest = {CS} (1-letter abbrev)</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let i = %eval(&amp;i+1);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;<ol><li>lines 484-491: end i loop through content strands</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let m=%eval(&amp;m + 1);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;<ol><li>lines 480-493 end - m loop through subjects</li></ol></li><li>&#160; &#160; &#160; &#160; run;<ol><li>Did run data step of line 471, output "School"</li><li>we did set vars bp{S}.ttest={CS} with bp {S} ccf of 1 and dp{S} ccf in (2,3).</li></ol></li><li>&#160; &#160; &#160; &#160; options Mprint;</li><li>&#160; &#160; &#160; &#160; Data district;<ol><li>lines 496-524</li><li>Start data step to output DS "district" covers through line 524</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; merge district(in=indistrict) &amp;districtds peercompare_out;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; by g_dcrxid;<ol><li>We merged several datasets:&#160;</li><li>&amp;districtds is a list mean_g_dcrxid, ttest, peercompare_out... maybe all output datasets for a district...&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array r_items(*) dprxit1-dprxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array m_items(*) dpmxit1-dpmxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array w_items(*) dpwxit1-dpwxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array s_items(*) dpsxit1-dpsxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array c_items(*) dpcxit1-dpcxit50;<ol><li>Did set {S}_items array from sheet Means rows for those vars: rows 51-271</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; %let m=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %do %while(%scan(&amp;subject_list,&amp;m) ne);<ol><li>lines 505-523: start m loop over subjects</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let sub_char=%scan(&amp;subject_list,&amp;m);</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let p=1;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%do %while(%scan(&amp;&amp;PeerOut_&amp;sub_char.,&amp;p) ne);*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let var=%scan(&amp;&amp;PeerOut_&amp;sub_char.,&amp;p);*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if dp&amp;sub_char.xscal=. then &amp;var=.;*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%let p=%eval(&amp;p + 1);*/</li><li>/* &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;%end;*/</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; dp&amp;sub_char.ttest="X";</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let i=1;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %do %while(%length(%scan(&amp;&amp;contentstrand_&amp;sub_char.,&amp;i.)));</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let cs=%scan(&amp;&amp;contentstrand_&amp;sub_char.,&amp;i);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %If &amp;CS. ne X %then %do;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if dp&amp;sub_char.&amp;cs.ccf=1 then dp&amp;sub_char.ttest="&amp;CS.";</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let i = %eval(&amp;i+1);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %let m=%eval(&amp;m + 1);</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; %end;<ol><li>lines 505-523: end m loop over subjects</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; if indistrict;</li><li>&#160; &#160; &#160; &#160; run;<ol><li>lines 496-525 end Data district&#160;</li><li>Created rows, each row with item-means for all subject-items per district, presumably</li><li>Did set dp_{S}.ttest to CS abbrev if db{S}{C}.ccf &#160;= 1... &#160;because..&#160;</li></ol></li><li>&#160; &#160; &#160; &#160; Data state1(drop=tmp:);<ol><li>loop lines 526-558: start Data state1</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; merge state(in=instate) mean_g_scrxid;<ol><li>&#160;mean_g_scrxid is output file/dataset that was genned by call to Means() on line 390.</li><li>merge syntax &#160;..&#160;<a href="http://support.sas.com/documentation/cdl/en/lestmtsref/63323/HTML/default/viewer.htm#n1i8w2bwu1fn5kn1gpxj18xttbb0.htm">http://support.sas.com/documentation/cdl/en/lestmtsref/63323/HTML/default/viewer.htm#n1i8w2bwu1fn5kn1gpxj18xttbb0.htm</a></li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; by g_scrxid;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; retain tmpsprxit1-tmpsprxit50 tmpspmxit1-tmpspmxit50 tmpspwxit1-tmpspwxit50 tmpspsxit1-tmpspsxit50 tmpspcxit1-tmpspcxit50;<ol><li>NOTE: the tmp* varnames are genned &#160;where? Have not deciphered means.sas yet....</li><li>The tmp*varnames are named in the agg sheet MEANS without the "tmp_" prefix...(means sheet rows 492 - 711)</li><li>NOTE: vars named sprxit* and the rest are in the Means_table or sheet... not sure where the tmp prefix originates...</li></ol></li><li>&#160; &#160; &#160; &#160; &#160; &#160; array r_items(*) sprxit1-sprxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array m_items(*) spmxit1-spmxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array w_items(*) spwxit1-spwxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array s_items(*) spsxit1-spsxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array c_items(*) spcxit1-spcxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array tmp_r_items(*) tmpsprxit1-tmpsprxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array tmp_m_items(*) tmpspmxit1-tmpspmxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array tmp_w_items(*) tmpspwxit1-tmpspwxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array tmp_s_items(*) tmpspsxit1-tmpspsxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; array tmp_c_items(*) tmpspcxit1-tmpspcxit50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if grade=10 then do;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; do i= 1 to 50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tmp_r_items[i]=r_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tmp_m_items[i]=m_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tmp_w_items[i]=w_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tmp_s_items[i]=s_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tmp_c_items[i]=c_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; end;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; end;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; else do;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; do i= 1 to 50;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; r_items[i]= tmp_r_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; m_items[i]= tmp_m_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; w_items[i]= tmp_w_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; s_items[i]= tmp_s_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;c_items[i]= tmp_c_items[i];</li><li>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; end;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; END;</li><li>&#160; &#160; &#160; &#160; &#160; &#160; if instate;</li><li>&#160; &#160; &#160; &#160; run;<ol><li>did data step at line 526 for output DS state1 to create various normalized array names.</li></ol></li><li>&#160; &#160; &#160; &#160; %Suppression(excel=N,agg_ds=supp_district,agg_file=,agg_sheet=,inputds=district, outputds=output.District)<ol><li>agg_ds is input SPEC "supp_district" here, from line 53, from agg file sheet suppression_district.</li><li>data input DS is 'district', from line 496.</li><li>outputds is output.District</li><li>this applies all the conditonal settings in the agg workbook sheet 'suppression_district' to produce the output dataset = "output.District"</li></ol></li><li>&#160; &#160; &#160; &#160; %Suppression(excel=N,agg_ds=supp_state,agg_file=,agg_sheet=,inputds=state1, outputds=output.State)<ol><li>input SPEC ds agg_ds from agg file, sheet suppression_state line 54</li><li>input DS is state1 from line 526</li><li>output DS is output.State</li><li>This applies all the conditonal settings in the agg workbook sheet 'suppression_state' to produce the output dataset = "output.State"</li></ol></li><li>&#160; &#160; &#160; &#160; %Suppression(excel=N,agg_ds=supp_school,agg_file=,agg_sheet=,inputds=school, outputds=output.school)<ol><li>input agg&#160;ds=supp_school, inputds="school"</li><li>inputds is Data school from line 471</li><li>output DS is output.school .</li><li>This applies all the conditonal settings in the agg workbook sheet 'suppression_school' to produce the output dataset = "output.Stateschool"</li></ol></li><li>%mend;<ol><li>end macro OGT... started at line 57</li></ol></li><li>/*Data OGT;*/</li><li>/*set input.ogt;*/</li><li>/*if ufxx_SAMPLE=1;*/</li><li>/*run;*/</li><li>/**/</li><li>/*proc freq data=input.ogt;*/</li><li>/*tables ufxx_sample/list;*/</li><li>/*run;*/</li><li>%OGT(inputds=input.ogt);<ol><li>Did run macro OGT</li><li>-</li></ol></li><li>Proc printto;</li><li>run;</li></ol></li></ol>

